[Introduction - CrewAI](https://docs.crewai.com/en/introduction)

!![Image Description](/images/Pasted%20image%20202509121.png.png)
不同的版本:  

1. CrewAI Enterprise
2. CrewAI UI Studio
3. CrewAI Open-Source Framework
	1. CrewAI Crews - Autonomous solutions with AI teams of Agents with different roles.
		1. Choose Crews when you need autonomous problem-solving, creative collaboration, or exploratory tasks.
	2. CrewAI Flows - Structured automations by dividing complex tasks into precise workflows.
		1. Choose Flows when you require deterministic outcomes, auditability, or precise control over execution._

  
Core concepts  

1. Agent
2. Task
3. Crew
4. Tools
5. Context

  
YAML Configuration to define agent

!![Image Description](/images/Pasted%20image%20202509122.png.png)


When creating an agent, we can just simply select the configuration as follows:  

agent = Agent(config=self.agents_config['researcher'])

  
crew.py  
It all comes together with a Crew definition  

!![Image Description](/images/Pasted%20image%20202509123.png.png)


LLMs  
CrewAI uses the super-simple LiteLLM under the hood to interface with almost any LLM; set keys in .env file. Not like LangChain, which comes with a fair amount of structure. LiteLLM is almost nothing.

!![Image Description](/images/Pasted%20image%20202509124.png.png)


Five Steps:  

1. Create the project with crewai create crew my_project
2. Fill in the config YAML files to define Agent and Task
3. Complete the crew.py module to create the Agent, Task and Crew, referencing the config
4. Update main.py to set any config
5. Run crewai run

uv tool install crewai  
crewai create crew my_crew  // Create a new project, aka an entire directory structure

my_crew  
	src  
		my_crew  
			config  
				agents.yaml  
				tasks.yaml  
			crew.py  
			main.py  
  
Then  
1. Structured output
2. Custom tool
3. Hierarchical process


#### More deeper - Memory, makes it more perscriptive

Five different types of memory  

1. Short-term memory
2. Long-term memory
3. Entity
4. Contextual memory
5. User memory